/**
\page basicconcepts Basic Concepts
\brief Basic C++ Programming Concepts used in building component software

\section abstractclassbasics Abstract Classes/Interfaces

Abstract classes (ideally) are those that that specify a number of pure virtual functions. 
They are called abstract because they don't describe a working class, but describe a 
functionality set. Abstract classes are also called interfaces. 
Standardized interfaces enable entities to communicate without
knowing anything about each another but the interface.

\subsection example1 Electric Socket Example

The electric socket interface is a description of the socket, but not the socket itself. 
This way, the electricians can install cables and provide sockets and devices can provide 
plugs that can be inserted into the sockets. 

\image html basicconceptsSockets.png


The key advantage of interface specification is that the parties in the communication are 
decoupled; hence the system becomes modular. Imagine if the device manufacturer had to 
provide custom electric sockets for each of their devices !

If we look at the term "interface" closely we can understand that an interface is nothing 
but a collection of functional (and sometimes physical) qualities of an entity. 

\subsection example2 Human Example

Lets list out some functional qualities of a man here

\li Student
\li Son
\li Boyfriend
\li Husband
\li Father

Each of the above have certain functional and physical qualities. 
A certain person can have more than one quality in him. For example there could be a guy 
who is a Son, Husband and Father. Lets name such a guy as "A". A's father is interested 
mostly in the "Son" capability of A, not in Husband or Father. Similarly A's wife is mostly 
interested in the "Husband" and "Father" capability of A and so on. So we can think of "Student",
"Son" etc as interfaces that A implements. Other people that interact with A are interested in 
one or more interfaces A implements while at the same time they are not bothered if A 
implements other interfaces also.


\section gcfconcepts Abstract classes/interfaces in GCF

Coming to C++, let's look at an actual example. GCF comes bundled with a few components, 
one of which is the property editor component. One of the key classes in the property 
editor component is called GCF::PropertyEditor. This class implements the IPropertyEditor 
interface. Before moving further let's take a look at the IPropertyEditor interface.


\code
class QObject;
class IContainer
{
public:
    virtual QObject*        containerObject() = 0;
};
class IValueEditorFactory;
class IProperty;
class IPropertyEditor : virtual public IContainer
{
public:
    // Establish which object to show the properties of.
    virtual void                setObject(QObject* object, bool recursive=false) = 0;
    virtual QObject*            object() = 0;

    // Methods to query property information
    virtual int                 propertyCount() = 0;
    virtual IProperty*          property(int index) = 0;

    // Establish the editor factory.
    virtual void                setEditorFactory(IValueEditorFactory* factory) = 0;
    virtual IValueEditorFactory* editorFactory() = 0;
};

Q_DECLARE_INTERFACE(IPropertyEditor, "com.vcreatelogic.IPropertyEditor/1.0")
\endcode


The above interfaces (IContainer and IPropertyEditor) only describe what 
the implementations must look like. They don't however describe the actual property 
editor class. Also you can notice that the IPropertyEditor interface implements 
the IContainer interface which has a method called containerObject(). What this 
means is that any class implementing IPropertyEditor must also implement IContainer. 
As a rule in GCF based applications, IContainer must be implemented only by QObject 
subclasses. This way by looking at an interface description we can figure out whether 
implementations of that interface have to be QObjects or not.


The actual GCF::PropertyEditor class looks like this


\code
struct GCF::PropertyEditorData;
class GCF::PropertyEditor : public QTreeWidget,
                        virtual public IPropertyEditor,
                        virtual public IDefaultPropertyManager,
                        virtual public IQObjectLoadSave
{
    Q_OBJECT
    Q_INTERFACES(IPropertyEditor IDefaultPropertyManager IQObjectLoadSave)

public:
    GCF::PropertyEditor(QWidget* parent=0);
    ~GCF::PropertyEditor();

    // IContainer implementation
    QObject* containerObject();

    // IPropertyEditor implementation
    void setObject(QObject* object, bool recursive=false);
    QObject* object();
    int propertyCount();
    IProperty* property(int index);
    void setEditorFactory(IValueEditorFactory* factory);
    IValueEditorFactory* editorFactory();

protected slots:
    void on_currentItemChanged(QTreeWidgetItem* current, QTreeWidgetItem* old);
    void on_editor_valueEdited();
    void on_propertyChanged(const QString& name);
    void refresh();

protected:
    bool eventFilter(QObject* object, QEvent* event);
    void addPropertiesFrom(QObject* object);
    void drawBranches(QPainter* p, const QRect & rect, const QModelIndex &) const;
    void mousePressEvent(QMouseEvent* me);

public:
    // IDefaultPropertyManager implementation
    void setDefaultProperty(QObject* object, IDefaultProperty* prop);
    IDefaultProperty* defaultProperty(QObject* object);

protected slots:
    void on_object_destroyed(QObject* obj);
    void on_object_propertyConfigurationChanged();

public:
    // IQObjectLoadSave
    bool saveProperties(QObject* object, QDomDocument doc, QDomElement parentE);
    bool loadProperties(QObject* object, QDomDocument doc, QDomElement parentE);

private:
    GCF::PropertyEditorData* d;
};
\endcode


As you can see the GCF::PropertyEditor class implements the IPropertyEditor interface, 
along with two other interfaces IDefaultPropertyManager and IQObjectLoadSave.


\image html basicconceptsPropertyEditor1.png


Interfaces IDefaultPropertyManager and IQObjectLoadSave look like below:


\code
class IQObjectLoadSave : virtual public IContainer
{
public:
    virtual bool saveProperties(QObject* obj, QDomDocument doc, QDomElement parentE) = 0;
    virtual bool loadProperties(QObject* obj, QDomDocument doc, QDomElement parentE) = 0;
};
Q_DECLARE_INTERFACE(IQObjectLoadSave, "com.vcreatelogic.IQObjectLoadSave/1.0")
class IDefaultPropertyManager : virtual public IContainer
{
public:
    virtual void setDefaultProperty(QObject* obj, IDefaultProperty* prop) = 0;
    virtual IDefaultProperty* defaultProperty(QObject* object) = 0;
};
Q_DECLARE_INTERFACE(IDefaultPropertyManager, "com.vcreatelogic.IDefaultPropertyManager/1.0");
\endcode

The IQObjectLoadSave interface must be implemented by an object that is capable of saving 
and loading all properties of a QObject into XML. This is especially useful for copy/cut/paste 
and load/save operations in an application.

The IDefaultPropertyManager interface must be implemented by an object that is capable of 
managing default properties of different configurable objects in the system. In 
VTK Designer the property editor shows a "X" button whenever it finds out that the 
value of a property is not default. 

Shown below is a screenshot of the property editor.

\image html basicconceptsPropertyEditor2.png


\section qtinterfaces Support for interfaces in Qt

It is quite possible, as shown by the GCF::PropertyEditor class, that an object can 
implement more than one interface. Users of the object may be interested in only a 
subset of those interfaces, hence there must be a way for users to query whether the 
object implements a particular interface or not.

Qt provides macros like Q_OBJECT, Q_INTERFACES, Q_DECLARE_INTERFACE to help deal 
with interfaces implemented by a QObject subclass.

\subsection declareinterface Q_DECLARE_INTERFACE

In the previous section you might have noticed that each interface was 
followed by a Q_DECLARE_INTERFACE line.

\code
class IQObjectLoadSave : virtual public IContainer
{
public:
    virtual bool saveProperties(QObject* obj, QDomDocument doc, QDomElement parentE) = 0;
    virtual bool loadProperties(QObject* obj, QDomDocument doc, QDomElement parentE) = 0;
};
Q_DECLARE_INTERFACE(IQObjectLoadSave, "com.vcreatelogic.IQObjectLoadSave/1.0")
\endcode

The  Q_DECLARE_INTERFACE macro helps declare a abstract C++ class as interface to Qt.

\subsection interfacesNobjects Q_INTERFACES and Q_OBJECT

QObject subclasses that implement one or more interfaces must contain a Q_OBJECT line 
and a Q_INTERFACES line in the class definition.

\code
struct GCF::PropertyEditorData;

class GCF::PropertyEditor : public QTreeWidget,
                        virtual public IPropertyEditor,
                        virtual public IDefaultPropertyManager,
                        virtual public IQObjectLoadSave
{
    Q_OBJECT
    Q_INTERFACES(IPropertyEditor IDefaultPropertyManager IQObjectLoadSave)
    
\endcode

While the Q_OBJECT macro informs the meta object compiler (MOC) of Qt to provide meta 
object information for the QObject subclass, the Q_INTERFACES macro informs MOC about 
the interfaces implemented by the QObject subclass.

\subsection qobjectcase qobject_cast<> operator

Qt provides a qobject_cast casting operator to cast QObject pointers into different 
pointer types. Suppose if you wanted to find out whether an object implements the 
IPropertyEditor interface or not you can

\code
QObject* obj = get_object_from_somewhere();
IPropertyEditor* propEditor = qobject_cast<IPropertyEditor*>(obj);
if(propEditor)
{
    // We make use of the property editor here.
}
\endcode

The qobject_cast operator can also be used to find out whether the QObject "containing" 
an interface has other interfaces also. For example:

\code
IPropertyEditor* propEditor = get_property_editor_from_somewhere()
IQObjectLoadSave* loadSave
    = qobject_cast<IQObjectLoadSave*>(propEditor->containerObject());
\endcode

\subsection nonqobjectinterfaces Handling interface implementations in non-QObject classes

QObject can turn out to be a heavy class for small uses. In such cases you may want to have 
simple C++ classes that implement one or more interfaces. The only disadvantage of having such 
classes is that you would not be able to make use of Qt's casting capabilities to find out 
whether an object implements a particular interface or not. As a workaround, in GCF based 
applications, we make use of the IQueryable interface.

For example, take a look at the following interfaces

\code
class IQueryable
{
public:
    virtual bool queryInterface(QString ifaceName, void** ifacePtr) = 0;
    virtual bool destroySelf() = 0;
};

class IVisSystemNodeIOData : virtual public IQueryable
{
public:
    virtual void* dataPointer() = 0;
    virtual QString dataTypeName() = 0;
};

class IVtkPolyDataMapperIOData : virtual public IVisSystemNodeIOData
{
public:
    virtual vtkPolyDataMapper* getVtkPolyDataMapper() = 0;
};
class IVtkObjectIOData : virtual public IVisSystemNodeIOData
{
public:
        virtual vtkObject* getVtkObject() = 0;
};
\endcode

IVtkObjectIOData and IVtkPolyDataMapperIOData are subclasses of IVisSystemNodeIOData, 
which is a subclass of IQueryable. The IVisSystemNodeIOData is used to represent 
connections between different nodes in VTK Designer.

\image html basicconceptsNodeConnection.png


When a connection is established between two nodes, the sender sends its output via 
an object that implements IVisSystemNodeIOData and the receiver gets a pointer to that object. 
The receiver node gets input as a IVisSystemNodeIOData pointer. From this it has to figure 
out whether the object provides the kind of data that it requires or not. This is done via 
the queryInterface() method of IQueryable. The code snippet shown below gives a demonstration of 
this.

\code

bool CVtkPolyDataMapper::setInput(IVisSystemNodeConnectionPath* path, IVisSystemNodeIOData* inputData)
{
    if(!path || !inputData)
        return false;

    if(path->pathName() == "PolyData")
    {
        IVtkPolyDataIOData* polyData = 0;
        bool success = inputData->queryInterface("IVtkPolyDataIOData", (void**)&polyData);
        if(success && polyData)
        {
            m_vtkPolyDataMapper->SetInput(polyData->getVtkPolyData());
            return true;
        }
    }

    return false;
}

\endcode


This way, we can even have non-QObject subclasses provide us the capability to explore 
the interfaces implemented by an object.


Developers who have worked on Microsoft's COM will be able to draw parallels between 
IQueryable and Iunknown. Microsoft's COM depends on interface ID's to identify interfaces 
but IQueryable uses simple strings. String comparison is much slower when compared to ID 
comparison, but the speed difference should be negligible.

*/

